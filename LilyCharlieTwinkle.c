/*
 * LilyCharlieTwinkle.c
 *
 * Created: 2/13/2013 12:25:45 PM
 *  Author: Bill Porter
 *		www.billporter.info
 *
 *
 *		Code to Charlieplex a LED matrix grid of 12 LEDs with twinkle effects using a LilyTiny (ATtiny85)
 *			LilyTiny has 0-3 broken out
 *				Twinkle effects generated by Vixen and converted for AVR use by Vixeno
 *					Customize twinkle effects or generate other animations using Vixen and Vixeno, 
 *						see http://www.billporter.info/?p=1458
 *
 *This work is licensed under the Creative Commons Attribution-ShareAlike 3.0 Unported License.
 *To view a copy of this license, visit http://creativecommons.org/licenses/by-sa/3.0/ or
 *send a letter to Creative Commons, 444 Castro Street, Suite 900, Mountain View, California, 94041, USA.
 *
 */ 

#define F_CPU 8000000UL

#include <avr/io.h>
#include <avr/interrupt.h>
#include <avr/pgmspace.h>
#include <util/delay.h>
#include "VixenShow.cpp"

//addressing arrays
//arrays hold DDRB and PORTB values need to drive the charlieplexed LED array
const uint8_t IOdirection[12] = {
	  ( 1<<PB0 | 1<<PB3 ), //LED 0
	  ( 1<<PB1 | 1<<PB3 ), // 1
	  ( 1<<PB2 | 1<<PB3 ), // 2
	  ( 1<<PB3 | 1<<PB2 ), // 3
	  
	  ( 1<<PB0 | 1<<PB2 ), // 4
	  ( 1<<PB1 | 1<<PB2 ), // 5
	  ( 1<<PB2 | 1<<PB1 ), // 6
	  ( 1<<PB3 | 1<<PB1 ), // 7
	  
	  ( 1<<PB0 | 1<<PB1 ), // 8
	  ( 1<<PB1 | 1<<PB0 ), // 9
	  ( 1<<PB2 | 1<<PB0 ), // 10
	  ( 1<<PB3 | 1<<PB0 ), // 11
	  };
	  
const uint8_t IOvalue[12] = {
	(1<<PB0), (1<<PB1), (1<<PB2), (1<<PB3),
	(1<<PB0), (1<<PB1), (1<<PB2), (1<<PB3),
	(1<<PB0), (1<<PB1), (1<<PB2), (1<<PB3)}; 


//globals
uint8_t LED;
volatile uint8_t values[12];

int main(void)
{
	
	//configure timers
	//using timer 0 for plexing LEDs
	TCCR0A = 0;
	TCCR0B = (1<<CS01); //timer clock div/8
	
	TIMSK = (1<<OCIE0A) | (1<<TOIE0); //compare match A interrupt and overflow interrupt enabled
	
	//enable interrupts
	sei();
	
    while(1)
    {
		
		//here we are going to load the show values for th current frame and delay. The interrupts will handle flashing the LEDs
		for(int i=0; i<vixen_frames; i++){
			for(int y=0; y<vixen_channels; y++){
				values[y]=pgm_read_byte(&(vixen_show_data[y][i]));
			}
			_delay_ms(vixen_frameduration);
		}						
			
    }
}

//timer compare match interrupt. Turn off led on compare
ISR(TIMER0_COMPA_vect){

	//turn off LED
	DDRB=0;

}

//timer overflow interrupt. Turn on next LED on overflow
ISR(TIMER0_OVF_vect){
	
	//turn on next LED
	LED++;
	if(LED>11) LED=0;
	
	//return if LED PWM value is 0
	if(values[LED]==0) return;
	
	//stop timer
	TCCR0B = 0;
	
	//load compare value
	OCR0A = values[LED];
	
	//clear count
	TCNT0 = 0;
	
	//set direction and IO register for this LED
	DDRB=IOdirection[LED];
	PORTB=IOvalue[LED];
	
	//clear interrupt, clear prescailer, start timer
	TIFR = (1<<OCF0A);
	GTCCR = (1<<PSR0);
	TCCR0B = (1<<CS01);
	
}